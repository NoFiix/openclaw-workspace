/**
 * poller.js v2 - Workflow complet Publisher ‚Üí Draft ‚Üí Validation ‚Üí Twitter
 *
 * Tout se passe dans la conv Publisher :
 * 1. Tu envoies tes num√©ros ‚Üí Claude g√©n√®re le thread
 * 2. Draft + boutons [‚úÖ Publier] [‚úèÔ∏è Modifier] [‚ùå Annuler]
 * 3a. Publier ‚Üí postThread() sur @CryptoRizon
 * 3b. Modifier ‚Üí tu expliques ‚Üí nouveau draft + boutons
 * 3c. Annuler ‚Üí fin
 */

const https  = require("https");
const fs     = require("fs");
const path   = require("path");

const { isSelectionMessage, getSelectedArticles, clearWaitingSelection } = require("./pending");
const { postThread } = require("./twitter");

const WORKSPACE   = "/home/node/.openclaw/workspace";
const OFFSET_FILE = path.join(WORKSPACE, "state", "poller_offset.json");
const DRAFT_FILE  = path.join(WORKSPACE, "state", "current_draft.json");

const BUILDER_TOKEN = process.env.BUILDER_TELEGRAM_BOT_TOKEN;
const BUILDER_CHAT  = process.env.BUILDER_TELEGRAM_CHAT_ID;
const ANTHROPIC_KEY = process.env.ANTHROPIC_API_KEY;

// ---------- √âtat modification en cours ----------
let waitingModification = false;

// ---------- Telegram ----------
function tgRequest(token, method, body) {
  return new Promise((resolve, reject) => {
    const data = JSON.stringify(body);
    const req = https.request({
      hostname: "api.telegram.org",
      path:     `/bot${token}/${method}`,
      method:   "POST",
      headers:  {
        "Content-Type":   "application/json",
        "Content-Length": Buffer.byteLength(data),
      },
    }, (res) => {
      let raw = "";
      res.on("data", c => raw += c);
      res.on("end", () => { try { resolve(JSON.parse(raw)); } catch { resolve({}); } });
    });
    req.on("error", reject);
    req.write(data);
    req.end();
  });
}

function sendMessage(text, replyMarkup = null) {
  const body = {
    chat_id:    BUILDER_CHAT,
    text,
    parse_mode: "HTML",
  };
  if (replyMarkup) body.reply_markup = replyMarkup;
  return tgRequest(BUILDER_TOKEN, "sendMessage", body);
}

function answerCallback(callbackQueryId, text) {
  return tgRequest(BUILDER_TOKEN, "answerCallbackQuery", {
    callback_query_id: callbackQueryId,
    text,
    show_alert: false,
  });
}

function getUpdates(offset) {
  return tgRequest(BUILDER_TOKEN, "getUpdates", {
    offset,
    timeout:         2,
    allowed_updates: ["message", "callback_query"],
  });
}

// ---------- Offset ----------
function getOffset() {
  try { return JSON.parse(fs.readFileSync(OFFSET_FILE, "utf8")).offset || 0; }
  catch { return 0; }
}
function saveOffset(offset) {
  fs.writeFileSync(OFFSET_FILE, JSON.stringify({ offset }));
}

// ---------- Draft persistance ----------
function saveDraft(tweets) {
  fs.writeFileSync(DRAFT_FILE, JSON.stringify({ tweets, savedAt: new Date().toISOString() }));
}
function loadDraft() {
  try { return JSON.parse(fs.readFileSync(DRAFT_FILE, "utf8")); }
  catch { return null; }
}
function clearDraft() {
  try { if (fs.existsSync(DRAFT_FILE)) fs.unlinkSync(DRAFT_FILE); } catch {}
}

// ---------- Boutons validation ----------
const VALIDATION_BUTTONS = {
  inline_keyboard: [[
    { text: "‚úÖ Publier",  callback_data: "publish" },
    { text: "‚úèÔ∏è Modifier", callback_data: "modify"  },
    { text: "‚ùå Annuler",  callback_data: "cancel"  },
  ]],
};

// ---------- Claude Sonnet ----------
async function callClaude(system, user) {
  const body = JSON.stringify({
    model:      "claude-sonnet-4-6",
    max_tokens: 1500,
    system,
    messages:   [{ role: "user", content: user }],
  });

  return new Promise((resolve, reject) => {
    const req = https.request({
      hostname: "api.anthropic.com",
      path:     "/v1/messages",
      method:   "POST",
      headers:  {
        "Content-Type":      "application/json",
        "Content-Length":    Buffer.byteLength(body),
        "x-api-key":         ANTHROPIC_KEY,
        "anthropic-version": "2023-06-01",
      },
    }, (res) => {
      let raw = "";
      res.on("data", c => raw += c);
      res.on("end", () => {
        try { resolve(JSON.parse(raw).content?.[0]?.text?.trim() || ""); }
        catch { reject(new Error("Erreur parsing Claude")); }
      });
    });
    req.on("error", reject);
    req.write(body);
    req.end();
  });
}

const COPYWRITER_SYSTEM = `Tu es le copywriter de CryptoRizon. Tu r√©diges des threads Twitter crypto en fran√ßais.

STYLE ‚Äî David Ogilvy, Gary Halbert, Stan Leloup, Antoine BM :
- Phrases ultra-courtes. Une id√©e par ligne. Jamais deux.
- Rythme rapide. Tension. Le lecteur ne peut pas s'arr√™ter.
- Ton direct, proche, l√©g√®rement familier mais cr√©dible.
- Jamais de remplissage. Chaque mot compte.
- Langue : fran√ßais uniquement.
- Maximum 1 emoji par tweet, jamais en d√©but de phrase.
- Z√©ro hashtag. Z√©ro lien dans les tweets.

STRUCTURE :
Tweet 1 = INTRODUCTION SIMPLE. Une phrase directe et impactante. 
  ‚Üí Style : ""ici les plus grosses actus crypto des derni√®res 24h."
  ‚Üí Pas de num√©ro devant ce tweet dans le format de sortie.
  ‚Üí Max 1 ligne.

Tweets suivants = UN tweet par article. Prends les 8 plus importants. Pas de regroupement.
  ‚Üí Num√©rotation : 1/8, 2/8... uniquement sur ces tweets, pas sur l'intro.

Tweets 2-N = Un fait par tweet :
  ‚Üí 2-3 phrases max. Fait + contexte + implication concr√®te.
  ‚Üí Mentionne la source naturellement dans le texte (ex: "Selon Bloomberg...")
  ‚Üí Pas de titre s√©par√©. Pas de num√©rotation.

Dernier tweet = la derni√®re actualit√©. Pas de CTA. Pas de conclusion. On termine sur un fait.

R√àGLES ABSOLUES :
- Extraire uniquement les faits. Jamais copier les formulations sources.
- Factuel. Z√©ro conseil financier. Z√©ro promesse de gain.
- Max 280 caract√®res par tweet.
- Max 8 tweets au total.

FORMAT DE SORTIE STRICT :
- Un tweet par ligne.
- S√©pare chaque tweet par une ligne vide.
- Rien d'autre. Pas d'introduction. Pas de commentaire. Pas de num√©rotation.`;

async function generateThread(selected) {
  const articlesText = selected.map((a, i) =>
    `${i + 1}. ${a.title} (${a.source})`
  ).join("\n");

  const user = `Voici les ${selected.length} articles s√©lectionn√©s.\nR√©dige un thread Twitter percutant dans le style CryptoRizon.\n\n${articlesText}`;

  return callClaude(COPYWRITER_SYSTEM, user);
}

async function modifyThread(currentThread, instructions) {
  const user = `Voici le thread actuel :\n\n${currentThread}\n\nInstructions de modification de Daniel :\n${instructions}\n\nR√©dige la version corrig√©e en gardant le m√™me style CryptoRizon.`;
  return callClaude(COPYWRITER_SYSTEM, user);
}

// ---------- Parse tweets ----------
function parseTweets(threadText) {
  return threadText
    .split(/\n\s*\n/)
    .map(t => t.trim())
    .filter(t => t.length > 0 && t.length <= 280);
}

// ---------- Envoi draft ----------
async function sendDraft(threadText) {
  const tweets = parseTweets(threadText);
  saveDraft(tweets);

  const preview = tweets.map((t, i) => `${i + 1}/${tweets.length} ${t}`).join("\n\n");
  const msg = `‚úçÔ∏è <b>DRAFT ‚Äî @CryptoRizon</b> (${tweets.length} tweets)\n\n${preview}`;

  await sendMessage(msg, VALIDATION_BUTTONS);
}

// ---------- Handlers ----------
async function handleSelection(text) {
  const result = getSelectedArticles(text);

  if (!result) {
    await sendMessage("‚ö†Ô∏è Aucune liste en attente. Lance d'abord le scraper.");
    return;
  }

  const { selected } = result;
  await sendMessage(`‚è≥ G√©n√©ration du thread pour ${selected.length} articles...`);

  try {
    const thread = await generateThread(selected);
    clearWaitingSelection();
    await sendDraft(thread);
    console.log(`[poller] Draft g√©n√©r√© ‚Äî ${selected.length} articles`);
  } catch (e) {
    console.error("[poller] Erreur g√©n√©ration:", e.message);
    await sendMessage(`‚ùå Erreur : ${e.message}`);
  }
}

async function handlePublish() {
  const draft = loadDraft();
  if (!draft) {
    await sendMessage("‚ùå Aucun draft en attente.");
    return;
  }

  await sendMessage("üöÄ Publication en cours sur @CryptoRizon...");

  const results = await postThread(draft.tweets);
  const success = results.filter(r => r.success).length;
  const failed  = results.filter(r => !r.success).length;

  if (success > 0) {
    const firstUrl = results.find(r => r.success)?.url || "";
    await sendMessage(
      `‚úÖ Thread publi√© ! ${success}/${draft.tweets.length} tweets.\nüîó ${firstUrl}`
    );
    clearDraft();
  } else {
    await sendMessage(`‚ùå √âchec publication. ${failed} erreurs.\nV√©rifie les credentials Twitter.`);
  }
}

async function handleModify() {
  waitingModification = true;
  await sendMessage("‚úèÔ∏è Dis-moi ce que tu veux modifier :");
}

async function handleModificationInstructions(instructions) {
  waitingModification = false;
  const draft = loadDraft();

  if (!draft) {
    await sendMessage("‚ùå Aucun draft en attente.");
    return;
  }

  await sendMessage("‚è≥ Modification en cours...");

  try {
    const currentThread = draft.tweets.join("\n\n");
    const newThread     = await modifyThread(currentThread, instructions);
    await sendDraft(newThread);
    console.log("[poller] Thread modifi√©");
  } catch (e) {
    console.error("[poller] Erreur modification:", e.message);
    await sendMessage(`‚ùå Erreur : ${e.message}`);
  }
}

async function handleCancel() {
  clearDraft();
  clearWaitingSelection();
  waitingModification = false;
  await sendMessage("‚ùå Draft annul√©.");
}

// ---------- Boucle principale ----------
async function pollLoop() {
  console.log("[poller] v2 d√©marr√© ‚Äî conv CryptoRizon Publisher");

  if (!BUILDER_TOKEN || !BUILDER_CHAT) {
    console.error("[poller] Variables BUILDER manquantes");
    process.exit(1);
  }

  let offset = getOffset();

  while (true) {
    try {
      const response = await getUpdates(offset);
      const updates  = response.result || [];

      for (const update of updates) {
        offset = update.update_id + 1;
        saveOffset(offset);

        // Boutons
        if (update.callback_query) {
          const cq     = update.callback_query;
          const chatId = String(cq.message?.chat?.id || "");
          if (chatId !== String(BUILDER_CHAT)) continue;

          await answerCallback(cq.id, "");

          if      (cq.data === "publish") await handlePublish();
          else if (cq.data === "modify")  await handleModify();
          else if (cq.data === "cancel")  await handleCancel();
          continue;
        }

        // Messages
        const msg  = update.message;
        if (!msg) continue;

        const text = (msg.text || "").trim();
        const from = String(msg.chat?.id || "");
        if (from !== String(BUILDER_CHAT)) continue;

        console.log(`[poller] Message: "${text}"`);

        if (waitingModification) {
          await handleModificationInstructions(text);
        } else if (isSelectionMessage(text)) {
          await handleSelection(text);
        }
      }

    } catch (e) {
      console.error("[poller] Erreur:", e.message);
    }

    await new Promise(r => setTimeout(r, 2000));
  }
}

pollLoop();
